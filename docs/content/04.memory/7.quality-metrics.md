---
title: Memory Quality Metrics
description: 记忆质量评估 - 多维度质量分析和不一致性检测
navigation:
  icon: i-lucide-gauge
---

# 记忆质量评估 (Memory Quality Metrics)

## 概述

Memory Quality Metrics 提供多维度的记忆质量评估系统，帮助识别和改进低质量记忆，确保 Agent 的记忆系统可靠性。

## 核心功能

- **多维度评分** - 准确性、完整性、一致性、时效性、相关性
- **不一致性检测** - 自动检测矛盾、重复、过时信息
- **质量分析器** - 生成质量报告和改进建议
- **质量驱动检索** - 根据质量分数优化检索排序
- **自动清理** - 可选的低质量记忆自动清理

## 快速开始

### 1. 创建质量评估系统

```go
package main

import (
    "context"
    "github.com/wordflowlab/agentsdk/pkg/memory"
)

func main() {
    // 创建质量评估系统
    config := memory.DefaultQualityMetricsConfig()
    qm := memory.NewQualityMetrics(config)

    // 评估记忆质量
    memoryWithScore := &memory.MemoryWithScore{
        DocID: "mem-123",
        Text:  "User prefers dark mode interface",
        Provenance: memory.NewProvenance(memory.SourceUserInput, "user-1"),
        Score: 0.85,
    }

    quality, err := qm.Evaluate(context.Background(), "mem-123", memoryWithScore)
    if err != nil {
        panic(err)
    }

    // 查看质量分数
    fmt.Printf("准确性: %.2f\n", quality.Score.Accuracy)
    fmt.Printf("完整性: %.2f\n", quality.Score.Completeness)
    fmt.Printf("一致性: %.2f\n", quality.Score.Consistency)
    fmt.Printf("时效性: %.2f\n", quality.Score.Timeliness)
    fmt.Printf("相关性: %.2f\n", quality.Score.Relevance)
    fmt.Printf("综合得分: %.2f\n", quality.Score.Overall)
}
```

### 2. 使用质量分析器

```go
// 创建分析器
qa := memory.NewQualityAnalyzer(qm, semanticMemory)

// 检测不一致性
inconsistencies, _ := qa.DetectInconsistencies(ctx, memories)

for _, inc := range inconsistencies {
    fmt.Printf("[%s] %s (严重程度: %.2f)\n",
        inc.Type, inc.Description, inc.Severity)
}

// 生成质量报告
report, _ := qa.GenerateReport(ctx, memories)
fmt.Printf("平均质量: %.2f\n", report.Stats.AverageQuality)
fmt.Printf("低质量记忆数: %d\n", report.Stats.LowQualityCount)

// 获取改进建议
improvements, _ := qa.SuggestImprovements(ctx)
for _, imp := range improvements {
    fmt.Printf("记忆 %s 需要改进:\n", imp.MemoryID)
    for _, suggestion := range imp.Suggestions {
        fmt.Printf("  - %s\n", suggestion)
    }
}
```

## 质量维度

### 1. 准确性 (Accuracy)

基于 Memory Provenance 的置信度评分：

- **高准确性** (>0.8): 来自可靠来源，有多个佐证
- **中等准确性** (0.5-0.8): 单一来源或部分验证
- **低准确性** (<0.5): 来源不明或未经验证

### 2. 完整性 (Completeness)

基于内容长度和元数据完整度：

- **评估因子**: 文本长度、元数据字段数量
- **sigmoid 函数**: 200 字符达到约 50% 完整性
- **元数据加成**: 有元数据提升 10%

### 3. 一致性 (Consistency)

基于佐证数量和内部一致性：

- **无佐证**: 30% 一致性
- **1-2 个佐证**: 40-60% 一致性
- **5+ 个佐证**: 80%+ 一致性

### 4. 时效性 (Timeliness)

基于记忆年龄的时间衰减：

- **配置参数**:
  - `MaxAge`: 最大有效期（默认 90 天）
  - `TimelinessDecay`: 每天衰减率（默认 1%）
- **计算公式**: `score = exp(-decay * days)`

### 5. 相关性 (Relevance)

直接使用检索时的相似度分数 (0.0-1.0)

## 综合得分计算

```go
Overall = Accuracy     * 0.3 +
          Completeness * 0.2 +
          Consistency  * 0.2 +
          Timeliness   * 0.15 +
          Relevance    * 0.15
```

可通过配置调整各维度权重。

## 不一致性检测

### 支持的类型

```go
// 1. 矛盾 (Contradiction)
memories := []memory.MemoryWithScore{
    {Text: "User is online"},
    {Text: "User is not online"}, // 矛盾!
}

// 2. 重复 (Duplicate)
memories := []memory.MemoryWithScore{
    {Text: "User logged in successfully"},
    {Text: "User logged in successfully"}, // 重复!
}

// 3. 过时 (Outdated)
// 超过 180 天自动检测

// 4. 低置信度 (Low Confidence)
// 置信度 < 0.4 自动检测
```

### 检测示例

```go
inconsistencies, _ := qa.DetectInconsistencies(ctx, memories)

for _, inc := range inconsistencies {
    switch inc.Type {
    case memory.InconsistencyContradiction:
        // 处理矛盾
    case memory.InconsistencyDuplicate:
        // 处理重复
    case memory.InconsistencyOutdated:
        // 处理过时
    case memory.InconsistencyLowConfidence:
        // 处理低置信度
    }
}
```

## 质量驱动检索

### 1. 按质量排序

```go
// 获取所有质量信息
qualities := make(map[string]*memory.MemoryQuality)
for _, q := range qm.GetAll() {
    qualities[q.MemoryID] = q
}

// 按质量重新排序检索结果
ranked := memory.RankByQuality(memories, qualities)
// 综合得分 = 质量分数 * 0.7 + 检索分数 * 0.3
```

### 2. 质量过滤

```go
// 只保留高质量记忆（>= 0.7）
highQuality := memory.FilterByQuality(memories, qualities, 0.7)
```

## 质量报告

```go
report, _ := qa.GenerateReport(ctx, memories)

// 统计信息
fmt.Printf("总记忆数: %d\n", report.Stats.TotalMemories)
fmt.Printf("平均质量: %.2f\n", report.Stats.AverageQuality)
fmt.Printf("高质量: %d, 中等: %d, 低质量: %d\n",
    report.Stats.HighQualityCount,
    report.Stats.MediumQualityCount,
    report.Stats.LowQualityCount)

// 维度分布
for dim, score := range report.DimensionScores {
    fmt.Printf("%s: %.2f\n", dim, score)
}

// TOP 问题
for _, issue := range report.TopIssues {
    fmt.Println(issue)
}

// 改进建议
for _, rec := range report.Recommendations {
    fmt.Println(rec)
}
```

## 配置参考

### QualityMetricsConfig

```go
config := memory.QualityMetricsConfig{
    // 维度权重（总和应为 1.0）
    AccuracyWeight:     0.3,
    CompletenessWeight: 0.2,
    ConsistencyWeight:  0.2,
    TimelinessWeight:   0.15,
    RelevanceWeight:    0.15,

    // 时效性配置
    MaxAge:          90 * 24 * time.Hour, // 90 天
    TimelinessDecay: 0.01,                // 1% 每天

    // 质量阈值
    MinQualityThreshold: 0.3, // 低于此值为低质量
    WarningThreshold:    0.5, // 低于此值发出警告

    // 自动清理
    EnableAutoCleanup:   true,
    AutoCleanupInterval: 24 * time.Hour,
}
```

## 高级用法

### 1. 自定义质量评估

```go
// 手动创建质量分数
quality := &memory.MemoryQuality{
    MemoryID: "custom-123",
    Score: memory.QualityScore{
        Accuracy:     0.9,
        Completeness: 0.8,
        Consistency:  0.7,
        Timeliness:   1.0,
        Relevance:    0.85,
        Overall:      0.85,
    },
    UpdatedAt: time.Now(),
}
```

### 2. 质量趋势分析

```go
// 获取统计信息随时间变化
stats1 := qm.GetStats()
// ... 一段时间后 ...
stats2 := qm.GetStats()

qualityChange := stats2.AverageQuality - stats1.AverageQuality
fmt.Printf("质量变化: %+.2f\n", qualityChange)
```

### 3. 批量质量评估

```go
for _, mem := range memories {
    _, _ = qm.Evaluate(ctx, mem.DocID, &mem)
}

// 获取低质量记忆
lowQuality := qm.GetLowQuality()
fmt.Printf("发现 %d 个低质量记忆\n", len(lowQuality))
```

## 最佳实践

### 1. 定期评估

```go
// 后台定期评估新记忆
ticker := time.NewTicker(1 * time.Hour)
go func() {
    for range ticker.C {
        // 获取最近添加的记忆
        recent := semanticMemory.RetrieveRecent(ctx, 100)

        // 评估质量
        for _, mem := range recent {
            _, _ = qm.Evaluate(ctx, mem.DocID, &mem)
        }
    }
}()
```

### 2. 质量门槛

```go
// 只存储高质量记忆
quality, _ := qm.Evaluate(ctx, memID, memory)
if quality.Score.Overall >= 0.7 {
    semanticMemory.Store(ctx, memory)
} else {
    log.Printf("拒绝低质量记忆: %.2f", quality.Score.Overall)
}
```

### 3. 不一致性处理

```go
inconsistencies, _ := qa.DetectInconsistencies(ctx, memories)

for _, inc := range inconsistencies {
    if inc.Type == memory.InconsistencyContradiction && inc.Severity > 0.8 {
        // 严重矛盾，发送警报
        alertSystem.Send("检测到严重矛盾", inc.Description)
    }

    if inc.Type == memory.InconsistencyDuplicate {
        // 自动删除重复记忆
        semanticMemory.Delete(ctx, inc.MemoryID2)
    }
}
```

### 4. 质量改进流程

```go
improvements, _ := qa.SuggestImprovements(ctx)

for _, imp := range improvements {
    // 获取原始记忆
    mem, _ := semanticMemory.Retrieve(ctx, imp.MemoryID)

    // 根据建议改进
    for _, suggestion := range imp.Suggestions {
        if strings.Contains(suggestion, "佐证") {
            // 寻找支持性证据
            corroboration := findCorroboration(mem)
            mem.Provenance.AddCorroboration(corroboration)
        }
    }

    // 重新评估
    qm.Evaluate(ctx, imp.MemoryID, mem)
}
```

## 测试

运行质量评估测试：

```bash
go test ./pkg/memory/... -run Quality -v
```

## 相关文档

- [Memory Provenance](/memory/provenance) - 记忆溯源
- [Memory Consolidation](/memory/consolidation) - 记忆合并
- [Context Engineering](/guides/advanced/context-engineering) - 完整实现指南

## 参考资源

- [Google Context Engineering Whitepaper](https://arxiv.org/abs/2410.01600)
- [Data Quality Dimensions](https://en.wikipedia.org/wiki/Data_quality)
