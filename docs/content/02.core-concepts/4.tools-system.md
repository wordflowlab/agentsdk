---
title: å·¥å…·ç³»ç»Ÿ
description: ç†è§£å·¥å…·æ³¨å†Œã€æ‰§è¡Œå’Œè‡ªå®šä¹‰å¼€å‘
navigation:
  icon: i-lucide-wrench
---

# å·¥å…·ç³»ç»Ÿ

AgentSDKçš„å·¥å…·ç³»ç»Ÿä¸ºAgentæä¾›äº†ä¸å¤–éƒ¨ä¸–ç•Œäº¤äº’çš„èƒ½åŠ›ã€‚ä»æ–‡ä»¶æ“ä½œåˆ°ç½‘ç»œè¯·æ±‚ï¼Œå·¥å…·è®©Agentèƒ½å¤Ÿæ‰§è¡Œå®é™…ä»»åŠ¡ã€‚

## ğŸ› ï¸ å·¥å…·æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯å·¥å…·ï¼Ÿ

å·¥å…·ï¼ˆToolï¼‰æ˜¯Agentå¯ä»¥è°ƒç”¨çš„å‡½æ•°ï¼Œç”¨äºæ‰§è¡Œç‰¹å®šä»»åŠ¡ï¼š

```
Agentæ€è€ƒ â†’ å†³å®šä½¿ç”¨å·¥å…· â†’ è°ƒç”¨å·¥å…· â†’ è·å–ç»“æœ â†’ ç»§ç»­æ€è€ƒ
```

### å·¥å…·çš„ä½œç”¨

- **æ‰©å±•èƒ½åŠ›**ï¼šè®©Agentèƒ½åšLLMæœ¬èº«åšä¸åˆ°çš„äº‹
- **å®æ—¶æ•°æ®**ï¼šè·å–æœ€æ–°ä¿¡æ¯ï¼ˆæœç´¢ã€APIè°ƒç”¨ï¼‰
- **å‰¯ä½œç”¨æ“ä½œ**ï¼šä¿®æ”¹æ–‡ä»¶ã€æ‰§è¡Œå‘½ä»¤
- **ç»“æ„åŒ–è¾“å‡º**ï¼šè¿”å›æ ¼å¼åŒ–æ•°æ®

## ğŸ“‹ Toolæ¥å£

### æ¥å£å®šä¹‰

```go
type Tool interface {
    // å·¥å…·åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
    Name() string

    // å·¥å…·æè¿°ï¼ˆå‘Šè¯‰LLMè¿™ä¸ªå·¥å…·çš„ç”¨é€”ï¼‰
    Description() string

    // è¾“å…¥å‚æ•°schemaï¼ˆJSON Schemaæ ¼å¼ï¼‰
    InputSchema() map[string]interface{}

    // æ‰§è¡Œå·¥å…·
    Execute(ctx context.Context, input map[string]interface{}) (interface{}, error)
}
```

### ç®€å•ç¤ºä¾‹

```go
type CalculatorTool struct{}

func (t *CalculatorTool) Name() string {
    return "calculator"
}

func (t *CalculatorTool) Description() string {
    return "æ‰§è¡Œæ•°å­¦è®¡ç®—ï¼Œæ”¯æŒåŠ å‡ä¹˜é™¤è¿ç®—"
}

func (t *CalculatorTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "expression": map[string]interface{}{
                "type":        "string",
                "description": "æ•°å­¦è¡¨è¾¾å¼ï¼Œä¾‹å¦‚: 2+2, 10*5",
            },
        },
        "required": []string{"expression"},
    }
}

func (t *CalculatorTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    expr := input["expression"].(string)

    // æ‰§è¡Œè®¡ç®—ï¼ˆå®é™…åº”ä½¿ç”¨å®‰å…¨çš„è¡¨è¾¾å¼è§£æå™¨ï¼‰
    result, err := evaluate(expr)
    if err != nil {
        return map[string]interface{}{
            "ok":    false,
            "error": err.Error(),
        }, nil  // æ³¨æ„ï¼šè¿”å›nil error
    }

    return map[string]interface{}{
        "ok":     true,
        "result": result,
    }, nil
}
```

## ğŸ“š å†…ç½®å·¥å…·

AgentSDKæä¾›ä¸°å¯Œçš„å†…ç½®å·¥å…·ï¼Œè¦†ç›–å¸¸è§ä½¿ç”¨åœºæ™¯ã€‚

### æ–‡ä»¶ç³»ç»Ÿå·¥å…·

#### fs_read

è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆæ”¯æŒåˆ†é¡µï¼‰ï¼š

```go
// å·¥å…·è°ƒç”¨
{
    "name": "fs_read",
    "input": {
        "path": "/README.md",
        "offset": 0,      // èµ·å§‹è¡Œå·ï¼ˆå¯é€‰ï¼‰
        "limit": 100      // è¯»å–è¡Œæ•°ï¼ˆå¯é€‰ï¼‰
    }
}

// è¿”å›ç»“æœ
{
    "ok": true,
    "content": "æ–‡ä»¶å†…å®¹...",
    "lines": 100,
    "total_lines": 250,
    "has_more": true
}
```

#### fs_write

å†™å…¥æ–‡ä»¶ï¼š

```go
{
    "name": "fs_write",
    "input": {
        "path": "/output.txt",
        "content": "Hello World"
    }
}
```

#### fs_edit

ç²¾ç¡®ç¼–è¾‘ï¼ˆå­—ç¬¦ä¸²æ›¿æ¢ï¼‰ï¼š

```go
{
    "name": "fs_edit",
    "input": {
        "path": "/config.json",
        "old_string": "\"debug\": false",
        "new_string": "\"debug\": true",
        "replace_all": false
    }
}
```

#### fs_ls

åˆ—å‡ºç›®å½•ï¼š

```go
{
    "name": "fs_ls",
    "input": {
        "path": "/src"
    }
}

// è¿”å›
{
    "ok": true,
    "entries": [
        {"name": "main.go", "size": 1024, "is_dir": false},
        {"name": "utils", "size": 0, "is_dir": true}
    ]
}
```

#### fs_glob

Globæ¨¡å¼åŒ¹é…ï¼š

```go
{
    "name": "fs_glob",
    "input": {
        "pattern": "**/*.go",
        "path": "/src"
    }
}
```

#### fs_grep

æ­£åˆ™æœç´¢ï¼š

```go
{
    "name": "fs_grep",
    "input": {
        "pattern": "func.*Error",
        "path": "/src",
        "glob": "*.go"
    }
}

// è¿”å›
{
    "ok": true,
    "matches": [
        {
            "file": "/src/main.go",
            "line": 42,
            "content": "func handleError(err error) {"
        }
    ]
}
```

### å‘½ä»¤æ‰§è¡Œå·¥å…·

#### bash_run

æ‰§è¡ŒBashå‘½ä»¤ï¼š

```go
{
    "name": "bash_run",
    "input": {
        "command": "go test ./...",
        "timeout": 30000  // æ¯«ç§’
    }
}

// è¿”å›
{
    "ok": true,
    "stdout": "PASS\nok\t...",
    "stderr": "",
    "exit_code": 0
}
```

### ç½‘ç»œå·¥å…·

#### http_fetch

HTTPè¯·æ±‚ï¼š

```go
{
    "name": "http_fetch",
    "input": {
        "url": "https://api.example.com/data",
        "method": "GET",
        "headers": {"Authorization": "Bearer token"},
        "body": null
    }
}
```

#### web_search

ç½‘ç»œæœç´¢ï¼ˆTavily APIï¼‰ï¼š

```go
{
    "name": "web_search",
    "input": {
        "query": "Goè¯­è¨€æ€§èƒ½ä¼˜åŒ–",
        "search_type": "general",  // general/news/finance
        "max_results": 5
    }
}
```

### ä»»åŠ¡ç®¡ç†å·¥å…·

#### todo_list

åˆ—å‡ºå¾…åŠäº‹é¡¹ï¼š

```go
{
    "name": "todo_list",
    "input": {}
}
```

#### todo_add

æ·»åŠ å¾…åŠï¼š

```go
{
    "name": "todo_add",
    "input": {
        "title": "å®ç°ç”¨æˆ·è®¤è¯",
        "description": "æ·»åŠ JWTè®¤è¯",
        "priority": "high"
    }
}
```

#### todo_update

æ›´æ–°å¾…åŠçŠ¶æ€ï¼š

```go
{
    "name": "todo_update",
    "input": {
        "id": "todo-123",
        "status": "completed"
    }
}
```

## ğŸ”§ å·¥å…·æ³¨å†Œ

### åˆ›å»ºæ³¨å†Œè¡¨

```go
import (
    "github.com/wordflowlab/agentsdk/pkg/tools"
    "github.com/wordflowlab/agentsdk/pkg/tools/builtin"
)

// åˆ›å»ºå·¥å…·æ³¨å†Œè¡¨
registry := tools.NewRegistry()
```

### æ³¨å†Œå†…ç½®å·¥å…·

```go
// æ–¹å¼1ï¼šæ³¨å†Œæ‰€æœ‰å†…ç½®å·¥å…·
builtin.RegisterAll(registry)

// æ–¹å¼2ï¼šé€‰æ‹©æ€§æ³¨å†Œ
registry.Register(builtin.NewFileSystemTool())
registry.Register(builtin.NewBashTool())
registry.Register(builtin.NewHTTPTool())
```

### æ³¨å†Œè‡ªå®šä¹‰å·¥å…·

```go
// æ³¨å†Œè‡ªå®šä¹‰å·¥å…·
registry.Register(&CalculatorTool{})
registry.Register(&WeatherTool{})
```

### åœ¨Agentä¸­ä½¿ç”¨

```go
ag, err := agent.Create(ctx, &types.AgentConfig{
    TemplateID: "assistant",
    // æŒ‡å®šå…è®¸ä½¿ç”¨çš„å·¥å…·
    Tools: []interface{}{
        "fs_read",     // å·¥å…·åç§°
        "fs_write",
        "bash_run",
        &MyTool{},     // æˆ–ç›´æ¥ä¼ å…¥å·¥å…·å®ä¾‹
    },
}, &agent.Dependencies{
    ToolRegistry: registry,
    // ...å…¶ä»–ä¾èµ–
})
```

## ğŸ¨ åˆ›å»ºè‡ªå®šä¹‰å·¥å…·

### åŸºç¡€å·¥å…·

```go
package mytools

import (
    "context"
    "encoding/json"
    "net/http"
)

type WeatherTool struct{}

func (t *WeatherTool) Name() string {
    return "get_weather"
}

func (t *WeatherTool) Description() string {
    return "è·å–æŒ‡å®šåŸå¸‚çš„å¤©æ°”ä¿¡æ¯"
}

func (t *WeatherTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "city": map[string]interface{}{
                "type":        "string",
                "description": "åŸå¸‚åç§°ï¼Œä¾‹å¦‚: Beijing, Shanghai",
            },
        },
        "required": []string{"city"},
    }
}

func (t *WeatherTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    city := input["city"].(string)

    // è°ƒç”¨å¤©æ°”API
    weather, err := t.fetchWeather(ctx, city)
    if err != nil {
        return map[string]interface{}{
            "ok":    false,
            "error": err.Error(),
        }, nil
    }

    return map[string]interface{}{
        "ok":          true,
        "city":        city,
        "temperature": weather.Temp,
        "condition":   weather.Condition,
        "humidity":    weather.Humidity,
    }, nil
}

func (t *WeatherTool) fetchWeather(ctx context.Context, city string) (*Weather, error) {
    // å®é™…APIè°ƒç”¨é€»è¾‘
    url := fmt.Sprintf("https://api.weather.com/v1/current?city=%s", city)
    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var weather Weather
    json.NewDecoder(resp.Body).Decode(&weather)
    return &weather, nil
}
```

### å¸¦çŠ¶æ€çš„å·¥å…·

```go
type CounterTool struct {
    count int
    mu    sync.Mutex
}

func (t *CounterTool) Name() string {
    return "counter"
}

func (t *CounterTool) Description() string {
    return "è®¡æ•°å™¨å·¥å…·ï¼Œå¯ä»¥å¢åŠ æˆ–æŸ¥è¯¢è®¡æ•°"
}

func (t *CounterTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "action": map[string]interface{}{
                "type": "string",
                "enum": []string{"increment", "get", "reset"},
            },
        },
        "required": []string{"action"},
    }
}

func (t *CounterTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    action := input["action"].(string)

    t.mu.Lock()
    defer t.mu.Unlock()

    switch action {
    case "increment":
        t.count++
        return map[string]interface{}{
            "ok":    true,
            "count": t.count,
        }, nil

    case "get":
        return map[string]interface{}{
            "ok":    true,
            "count": t.count,
        }, nil

    case "reset":
        t.count = 0
        return map[string]interface{}{
            "ok":      true,
            "message": "è®¡æ•°å™¨å·²é‡ç½®",
        }, nil

    default:
        return map[string]interface{}{
            "ok":    false,
            "error": "æœªçŸ¥æ“ä½œ",
        }, nil
    }
}
```

### å¼‚æ­¥å·¥å…·

```go
type AsyncTool struct{}

func (t *AsyncTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    // åˆ›å»ºåå°ä»»åŠ¡
    taskID := uuid.New().String()

    go func() {
        // é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
        time.Sleep(10 * time.Second)
        result := processLongTask(input)

        // å°†ç»“æœå­˜å‚¨åˆ°æŸå¤„
        store.SaveResult(taskID, result)
    }()

    return map[string]interface{}{
        "ok":      true,
        "task_id": taskID,
        "status":  "processing",
        "message": "ä»»åŠ¡å·²å¯åŠ¨ï¼Œè¯·ä½¿ç”¨task_idæŸ¥è¯¢ç»“æœ",
    }, nil
}
```

## ğŸ”„ å·¥å…·æ‰§è¡Œæµç¨‹

### å®Œæ•´æµç¨‹

```
1. LLMå†³å®šä½¿ç”¨å·¥å…·
     â”‚
     â–¼
2. ç”Ÿæˆtool_useå—
     â”‚  {
     â”‚    "type": "tool_use",
     â”‚    "id": "toolu_123",
     â”‚    "name": "fs_read",
     â”‚    "input": {"path": "/file.txt"}
     â”‚  }
     â–¼
3. Agentæå–å·¥å…·è°ƒç”¨
     â”‚
     â–¼
4. æŸ¥æ‰¾å·¥å…·ï¼ˆRegistry.GetToolï¼‰
     â”‚
     â–¼
5. éªŒè¯è¾“å…¥ï¼ˆInputSchemaï¼‰
     â”‚
     â–¼
6. é€šè¿‡ä¸­é—´ä»¶æ ˆï¼ˆWrapToolCallï¼‰
     â”‚
     â–¼
7. æ‰§è¡Œå·¥å…·ï¼ˆtool.Executeï¼‰
     â”‚
     â–¼
8. æ„é€ tool_resultæ¶ˆæ¯
     â”‚  {
     â”‚    "type": "tool_result",
     â”‚    "tool_use_id": "toolu_123",
     â”‚    "content": "{\"ok\": true, ...}"
     â”‚  }
     â–¼
9. ç»§ç»­å¯¹è¯
```

### é”™è¯¯å¤„ç†

**é‡è¦**ï¼šå·¥å…·åº”è¯¥è¿”å›ç»“æ„åŒ–é”™è¯¯ï¼Œè€Œä¸æ˜¯Go errorï¼š

```go
// âœ… æ¨èï¼šè¿”å›ç»“æ„åŒ–é”™è¯¯
func (t *MyTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    result, err := doSomething()
    if err != nil {
        return map[string]interface{}{
            "ok":    false,
            "error": err.Error(),
            "suggestions": []string{
                "æ£€æŸ¥è¾“å…¥å‚æ•°",
                "ç¡®è®¤æƒé™è®¾ç½®",
            },
        }, nil  // è¿”å›nil errorï¼
    }

    return map[string]interface{}{
        "ok":     true,
        "result": result,
    }, nil
}

// âŒ ä¸æ¨èï¼šç›´æ¥è¿”å›error
func (t *MyTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    result, err := doSomething()
    if err != nil {
        return nil, err  // LLMçœ‹ä¸åˆ°é”™è¯¯ä¿¡æ¯
    }
    return result, nil
}
```

**åŸå› **ï¼šLLMéœ€è¦çœ‹åˆ°é”™è¯¯ä¿¡æ¯æ‰èƒ½å°è¯•æ¢å¤æˆ–ç»™å‡ºå»ºè®®ã€‚

## ğŸ¯ é«˜çº§æ¨¡å¼

### å·¥å…·ç»„åˆ

```go
type CompositeTool struct {
    tools []Tool
}

func (t *CompositeTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    results := make([]interface{}, 0)

    // ä¾æ¬¡æ‰§è¡Œå¤šä¸ªå·¥å…·
    for _, tool := range t.tools {
        result, err := tool.Execute(ctx, input)
        if err != nil {
            return nil, err
        }
        results = append(results, result)
    }

    return map[string]interface{}{
        "ok":      true,
        "results": results,
    }, nil
}
```

### å·¥å…·ä»£ç†

```go
type ProxyTool struct {
    target Tool
}

func (t *ProxyTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    // å‰ç½®å¤„ç†
    log.Printf("æ‰§è¡Œå·¥å…·: %s", t.target.Name())
    start := time.Now()

    // æ‰§è¡Œç›®æ ‡å·¥å…·
    result, err := t.target.Execute(ctx, input)

    // åç½®å¤„ç†
    duration := time.Since(start)
    log.Printf("å·¥å…·å®Œæˆ: %s, è€—æ—¶: %v", t.target.Name(), duration)

    return result, err
}
```

### æ¡ä»¶å·¥å…·

```go
type ConditionalTool struct {
    condition func(map[string]interface{}) bool
    trueTool  Tool
    falseTool Tool
}

func (t *ConditionalTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    if t.condition(input) {
        return t.trueTool.Execute(ctx, input)
    }
    return t.falseTool.Execute(ctx, input)
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. æ¸…æ™°çš„æè¿°

```go
// âœ… æ¨èï¼šå…·ä½“çš„æè¿°
func (t *Tool) Description() string {
    return "ä»æŒ‡å®šURLä¸‹è½½æ–‡ä»¶åˆ°æœ¬åœ°ç›®å½•ã€‚æ”¯æŒHTTP/HTTPSï¼Œå¯é…ç½®è¶…æ—¶ã€‚è¿”å›ä¸‹è½½çš„æ–‡ä»¶è·¯å¾„å’Œå¤§å°ã€‚"
}

// âŒ ä¸æ¨èï¼šæ¨¡ç³Šçš„æè¿°
func (t *Tool) Description() string {
    return "ä¸‹è½½æ–‡ä»¶"
}
```

### 2. å®Œæ•´çš„Schema

```go
// âœ… æ¨èï¼šè¯¦ç»†çš„schema
func (t *Tool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "url": map[string]interface{}{
                "type":        "string",
                "description": "è¦ä¸‹è½½çš„æ–‡ä»¶URL",
                "pattern":     "^https?://",
            },
            "output_path": map[string]interface{}{
                "type":        "string",
                "description": "ä¿å­˜æ–‡ä»¶çš„æœ¬åœ°è·¯å¾„",
            },
            "timeout": map[string]interface{}{
                "type":        "integer",
                "description": "è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤60ç§’",
                "default":     60,
                "minimum":     1,
                "maximum":     300,
            },
        },
        "required": []string{"url"},
    }
}
```

### 3. ç»“æ„åŒ–è¾“å‡º

```go
// âœ… æ¨èï¼šç»“æ„åŒ–è¿”å›
return map[string]interface{}{
    "ok":        true,
    "file_path": "/downloads/file.pdf",
    "file_size": 1048576,
    "mime_type": "application/pdf",
    "duration":  "2.5s",
}, nil

// âŒ ä¸æ¨èï¼šå­—ç¬¦ä¸²è¿”å›
return "æ–‡ä»¶å·²ä¸‹è½½åˆ° /downloads/file.pdf", nil
```

### 4. å¹‚ç­‰æ€§

```go
// å·¥å…·åº”è¯¥å°½å¯èƒ½å¹‚ç­‰
func (t *CreateFileTool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    path := input["path"].(string)

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
    if fileExists(path) {
        return map[string]interface{}{
            "ok":      true,
            "existed": true,
            "message": "æ–‡ä»¶å·²å­˜åœ¨",
        }, nil
    }

    // åˆ›å»ºæ–‡ä»¶
    return createFile(path)
}
```

### 5. è¶…æ—¶æ§åˆ¶

```go
func (t *Tool) Execute(ctx context.Context, input map[string]interface{}) (interface{}, error) {
    // ä½¿ç”¨contextæ§åˆ¶è¶…æ—¶
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    // å¯å–æ¶ˆçš„æ“ä½œ
    result := make(chan interface{}, 1)
    go func() {
        result <- doWork()
    }()

    select {
    case r := <-result:
        return r, nil
    case <-ctx.Done():
        return map[string]interface{}{
            "ok":    false,
            "error": "æ“ä½œè¶…æ—¶",
        }, nil
    }
}
```

## ğŸ“š ä¸‹ä¸€æ­¥

- [ä¸­é—´ä»¶ç³»ç»Ÿ](/core-concepts/middleware) - ç†è§£å·¥å…·å¦‚ä½•é€šè¿‡ä¸­é—´ä»¶æ ˆæ‰§è¡Œ
- [æ²™ç®±ç³»ç»Ÿ](/core-concepts/sandbox) - ç†è§£å·¥å…·åœ¨æ²™ç®±ä¸­çš„æ‰§è¡Œ
- [å®æˆ˜æŒ‡å—](/guides/custom-tools) - å®Œæ•´çš„è‡ªå®šä¹‰å·¥å…·å¼€å‘ç¤ºä¾‹
- [APIå‚è€ƒ](/api-reference/tools-api) - è¯¦ç»†çš„Tools APIæ–‡æ¡£

## ğŸ”— ç›¸å…³èµ„æº

- [å†…ç½®å·¥å…·æºç ](https://github.com/wordflowlab/agentsdk/tree/main/pkg/tools/builtin)
- [å·¥å…·ç¤ºä¾‹](https://github.com/wordflowlab/agentsdk/tree/main/examples/tools)
- [MCPå·¥å…·é›†æˆ](/guides/mcp-integration)
