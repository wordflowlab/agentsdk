---
title: Memory 系统指南
description: 短期记忆、长期记忆、语义记忆的整体设计与用法
navigation: false
---

# Memory 系统指南

AgentSDK 提供了分层的 Memory 管理系统，帮助 Agent 在会话内外保持状态和记忆：

1. **短期记忆（Short-term / Working Memory）** - 当前会话/任务的工作记忆
2. **长期记忆（Long-term Memory）** - 跨会话、跨任务的持久记忆（文件 + 语义）
3. **语义记忆（Semantic Memory）** - 基于向量检索的语义知识库

## 概述

### 短期 vs 长期记忆

| 特性 | 短期记忆（Short-term / Working） | 长期记忆（Long-term Text / Semantic） |
|------|---------------------------------|---------------------------------------|
| **用途** | 当前会话/任务的状态、临时结果 | 跨会话的知识、偏好、项目文档 |
| **作用域** | 单个 Session / Thread / 资源 | 用户 / 项目 / 资源 / 全局 |
| **存储方式** | Session 状态 + Working Memory | 文件(Markdown) + 向量索引 |
| **更新方式** | 频繁覆盖/更新 | 追加/归档/索引 |
| **生命周期** | 会话内，或短期 TTL | 长期持久，可备份 |
| **读取方式** | 直接注入上下文 | grep / semantic_search 按需检索 |

**使用短期记忆：**
- 跟踪当前会话的结构化状态（当前任务、进度、用户选择）
- 在工作流中传递中间结果
- 需要每轮对话都带入 system prompt 的少量关键信息

**使用长期记忆：**
- 存储长期知识（文档、经验总结、设计决策）
- 跨会话保留用户偏好、项目背景
- 需要全文/语义搜索的大体量内容

---

## 文本记忆（Text Memory）

### 配置

在 `agentsdk.yaml` 中配置：

```yaml
memory:
  text:
    enabled: true
    path: "/memories/"
    base_namespace: ""  # 可选：多租户隔离
```

### 核心概念

#### Namespace（命名空间）

Namespace 用于组织和隔离记忆：

```
/memories/
  ├── users/
  │   ├── alice/
  │   │   ├── profile.md
  │   │   └── preferences.md
  │   └── bob/
  │       └── profile.md
  ├── projects/
  │   ├── demo/
  │   │   └── notes.md
  │   └── prod/
  │       └── checklist.md
  └── shared/
      └── guidelines.md
```

#### Scope（作用域）

使用 `Scope` 结构体生成 namespace：

```go
import "github.com/wordflowlab/agentsdk/pkg/memory"

// 用户私有记忆
scope := memory.Scope{
    UserID:     "alice",
    ProjectID:  "demo",
    Shared:     false,  // 不是共享记忆
}
ns := scope.Namespace()  // "projects/demo"
// 实际路径: /memories/users/alice/projects/demo/

// 全局共享记忆
sharedScope := memory.Scope{
    ProjectID:  "demo",
    Shared:     true,   // 全局共享
}
ns = sharedScope.Namespace()  // "/projects/demo"
// 实际路径: /memories/projects/demo/
```

### 使用方式

#### 1. 通过 Middleware 工具

最简单的方式是使用 `AgentMemoryMiddleware` 提供的工具：

```go
// 在 Agent 配置中启用
config := &types.AgentConfig{
    // ...
    Middlewares: []string{"filesystem", "agent_memory"},
}
```

Agent 会自动获得两个工具：
- `memory_search` - 搜索记忆
- `memory_write` - 写入记忆

#### 2. 直接使用 Manager API

```go
import (
    "github.com/wordflowlab/agentsdk/pkg/backends"
    "github.com/wordflowlab/agentsdk/pkg/memory"
)

// 创建 Backend
backend := backends.NewLocalBackend("./memories")

// 创建 Memory Manager
manager, err := memory.NewManager(&memory.ManagerConfig{
    Backend:    backend,
    MemoryPath: "/memories/",
})

// 追加笔记
path, err := manager.AppendNote(ctx,
    "users/alice/profile.md",
    "2025-01-14",  // 标题
    "Alice prefers concise code reviews")  // 内容

// 覆盖笔记
path, err := manager.OverwriteWithNote(ctx,
    "users/alice/status.md",
    "Current Status",
    "Working on memory system")

// 搜索
matches, err := manager.Search(ctx, &memory.SearchOptions{
    Query:      "code review",
    Namespace:  "users/alice",  // 限制搜索范围
    Glob:       "*.md",
    MaxResults: 10,
})

// 读取文件
content, err := manager.ReadFile(ctx, "users/alice/profile.md")
```

### 工具使用示例

当 Agent 启用 `agent_memory` 中间件后，LLM 可以这样使用工具：

```json
// memory_write - 写入新记忆
{
  "file": "project_notes.md",
  "mode": "append",
  "title": "Design Decision",
  "content": "We decided to use Working Memory for session state",
  "namespace": "projects/demo"
}

// memory_search - 搜索记忆
{
  "query": "design decision",
  "namespace": "projects/demo",
  "glob": "*.md",
  "max_results": 5
}
```

---

## Working Memory

### 配置

在 `agentsdk.yaml` 中配置：

```yaml
memory:
  working_memory:
    enabled: true
    scope: "thread"  # "thread" | "resource"
    base_path: "/working_memory/"
    ttl: 0  # 过期时间（秒），0表示不过期

    # 可选：JSON Schema 定义
    schema:
      type: object
      properties:
        user_name:
          type: string
        task_status:
          type: string
          enum: ["not_started", "in_progress", "completed"]
        preferences:
          type: array
          items:
            type: string
      required: ["user_name"]

    # 可选：Markdown 模板（与 schema 互斥）
    # template: |
    #   # User: {{.user_name}}
    #   ## Task Status: {{.task_status}}
```

### Scope 详解

#### Thread Scope（会话级）

每个 thread（会话）有独立的 Working Memory：

```
/working_memory/threads/
  ├── thread-001.json
  ├── thread-002.json
  └── thread-003.json
```

**适用场景：**
- 独立的用户会话
- 不同上下文的对话
- 需要隔离状态

#### Resource Scope（资源级）

同一 resource 的所有 threads 共享 Working Memory：

```
/working_memory/resources/
  ├── article-123.json
  ├── novel-456.json
  └── project-789.json
```

**适用场景：**
- 多轮协作编辑同一文档
- 团队共享的项目状态
- 长期追踪的资源状态

### 使用方式

#### 1. 通过 Middleware（推荐）

```go
// 创建 Working Memory Middleware
wmMiddleware, err := middleware.NewWorkingMemoryMiddleware(
    &middleware.WorkingMemoryMiddlewareConfig{
        Backend:  backend,
        BasePath: "/working_memory/",
        Scope:    memory.ScopeThread,
        Schema:   jsonSchema,  // 可选
    },
)

// 添加到 Agent
config := &types.AgentConfig{
    // ...
    Middlewares: []string{"filesystem", "agent_memory", "working_memory"},
}
```

Agent 会自动获得：
- `update_working_memory` - 更新 Working Memory

Working Memory 内容会自动注入到每轮对话的 system prompt。

#### 2. 直接使用 Manager API

```go
import "github.com/wordflowlab/agentsdk/pkg/memory"

// 创建 Working Memory Manager
manager, err := memory.NewWorkingMemoryManager(&memory.WorkingMemoryConfig{
    Backend:  backend,
    BasePath: "/working_memory/",
    Scope:    memory.ScopeThread,
})

// 获取 Working Memory
content, err := manager.Get(ctx, "thread-001", "resource-123")

// 更新 Working Memory
err = manager.Update(ctx, "thread-001", "resource-123", `
# User Profile
Name: Alice
Preferences:
- Concise code reviews
- Markdown formatting

## Current Task
Status: in_progress
Description: Implementing memory system
`)

// Find and Replace（实验性功能）
err = manager.FindAndReplace(ctx,
    "thread-001",
    "resource-123",
    "Status: in_progress",    // 查找
    "Status: completed")       // 替换

// 删除 Working Memory
err = manager.Delete(ctx, "thread-001", "resource-123")
```

### 工具使用示例

当 Agent 启用 `working_memory` 中间件后，LLM 可以这样使用工具：

```json
// update_working_memory - 更新状态
{
  "memory": "# User Profile\nName: Alice\nRole: Engineer\n\n## Preferences\n- Prefers TypeScript\n- Uses VS Code\n\n## Current Task\nStatus: in_progress\nGoal: Complete memory system documentation"
}
```

**重要：** `update_working_memory` 会**覆盖**整个 Working Memory，因此必须包含所有要保留的信息。

### Schema 验证

如果配置了 JSON Schema，Working Memory 内容必须是有效的 JSON：

```yaml
# 配置 Schema
working_memory:
  schema:
    type: object
    properties:
      user_name: {type: string}
      task_status: {type: string}
    required: ["user_name"]
```

```go
// 有效的更新
manager.Update(ctx, threadID, resourceID, `{
  "user_name": "Alice",
  "task_status": "in_progress"
}`)

// 无效的更新（缺少 required 字段）
manager.Update(ctx, threadID, resourceID, `{
  "task_status": "in_progress"
}`)  // 返回错误
```

### TTL（过期时间）

配置 TTL 后，Working Memory 会在指定时间后自动失效：

```yaml
working_memory:
  ttl: 3600  # 1小时后过期
```

```go
// 使用 TTL
manager, err := memory.NewWorkingMemoryManager(&memory.WorkingMemoryConfig{
    Backend:    backend,
    DefaultTTL: 1 * time.Hour,
    // ...
})
```

---

## 语义记忆（Semantic Memory）

语义记忆基于向量检索，适用于大规模知识库的语义搜索。

### 配置（agentsdk.yaml）

语义记忆由三部分组成：

- `vector_stores`：向量存储后端（内存 / pgvector / 其他适配器）
- `embedders`：向量生成后端（Mock / OpenAI / 本地模型）
- `semantic_memory`：语义记忆配置（是否启用、命名空间策略等）

示例：

```yaml
vector_stores:
  - name: main
    kind: memory          # 或 pgvector 等
    # dsn/table/metric/dimension 等参数由具体 kind 决定

embedders:
  - name: default
    kind: mock            # 或 openai/local 等
    model: text-embedding-3-small
    env_api_key: OPENAI_API_KEY

semantic_memory:
  enabled: true
  store: main             # 引用上面的 vector_stores.name
  embedder: default       # 引用上面的 embedders.name
  top_k: 8
  namespace_scope: resource   # "user" | "project" | "resource" | "global"
```

### 使用方式

```go
import "github.com/wordflowlab/agentsdk/pkg/memory"

// 创建 Semantic Memory
semantic := memory.NewSemanticMemory(memory.SemanticMemoryConfig{
    Store:          vectorStore,
    Embedder:       embedder,
    NamespaceScope: "resource",
    TopK:           5,
})

// 索引文本
err = semantic.Index(ctx,
    "doc-123",  // 文档 ID
    "AgentSDK provides two memory systems...",  // 文本
    map[string]interface{}{
        "user_id":     "alice",
        "resource_id": "article-123",
    })

// 语义搜索
hits, err := semantic.Search(ctx,
    "How to use memory?",  // 查询
    map[string]interface{}{
        "resource_id": "article-123",
    },
    5)  // topK
```

---

## 最佳实践

### 1. 选择合适的 Memory 类型

```
[用户询问] → 需要记住吗？
                ↓ 是
        是结构化状态吗？
                ↓ 是
        需要每次对话加载吗？
                ↓ 是
        → 使用 Working Memory

        ↓ 否（大文档/历史记录）
        → 使用文本记忆

        ↓ 需要语义搜索？
        → 使用语义记忆
```

### 2. Working Memory 最佳实践

**✅ 推荐：**
- 保持 Working Memory 简洁（< 500 words）
- 使用清晰的 Markdown 结构
- 定期清理不再需要的信息
- 使用 Schema 确保数据一致性

**❌ 避免：**
- 在 Working Memory 中存储大量历史记录
- 存储临时的、不需要跨轮保持的数据
- 忘记更新时包含所有要保留的信息

### 3. 文本记忆最佳实践

**✅ 推荐：**
- 使用有意义的文件名和 namespace
- 为每条笔记添加时间戳标题
- 使用 `append` 模式保留历史
- 定期搜索检查记忆内容

**❌ 避免：**
- 频繁覆盖重要的历史记录
- 在单个文件中混合不同主题
- 使用过深的 namespace 层级

### 4. 组合使用

```go
// Working Memory: 当前会话状态
{
  "user_name": "Alice",
  "current_task": "Documenting memory system",
  "task_status": "in_progress"
}

// 文本记忆: 详细的历史记录
/memories/users/alice/
  └── projects/agentsdk/
      ├── decisions.md  ← 设计决策历史
      ├── progress.md   ← 项目进展记录
      └── learnings.md  ← 经验总结

// 语义记忆: 知识库（如果启用）
向量索引包含所有文档的 embedding，支持语义搜索
```

---

## 故障排除

### Working Memory 未加载

**问题：** Agent 没有加载 Working Memory

**解决：**
1. 检查 `agentsdk.yaml` 中 `memory.working_memory.enabled` 是否为 `true`
2. 确认 Middleware 已正确注册
3. 查看日志确认是否有加载错误

### Schema 验证失败

**问题：** 更新 Working Memory 时报 schema 验证错误

**解决：**
1. 确保内容是有效的 JSON（如果配置了 object schema）
2. 检查是否包含所有 `required` 字段
3. 验证字段类型是否匹配 schema 定义

### Namespace 混淆

**问题：** 找不到之前写入的记忆

**解决：**
1. 检查 namespace 是否一致
2. 注意 `Shared: true` 会添加前导 `/`
3. 使用 `memory_search` 不带 namespace 参数进行全局搜索

---

## 示例

完整示例参见：
- `examples/memory/` - 基础文本记忆示例
- `examples/memory-agent/` - 带记忆的 Agent 示例
- `examples/memory-working/` - Working Memory 示例
- `examples/memory-semantic/` - 语义记忆示例

---

## API Reference

详细 API 文档参见：
- [Memory API Reference](../6.api-reference/memory-api.md)
- [Middleware API Reference](../6.api-reference/3.middleware-api.md)
