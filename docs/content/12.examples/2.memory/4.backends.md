---
title: Memory 后端适配
description: 短期/长期/语义记忆的后端类型与配置说明
navigation: false
---

# Memory 后端适配

本节整理 AgentSDK 中与记忆相关的后端类型, 帮助你在「短期记忆 vs 长期记忆」之间做出合理选择, 并为不同环境选择合适的存储实现。

## 1. 概览

| 记忆层级 | 主要 API / 组件 | 典型后端 | 适用场景 |
|----------|-----------------|----------|----------|
| 短期记忆 | `session.Service` + `WorkingMemory` | 内存 / MySQL / PostgreSQL | 当前会话/任务状态 |
| 长期记忆 | `memory.Manager` + `AgentMemoryMiddleware` | 文件系统 | 用户/项目/资源长期记忆 |
| 语义记忆 | `SemanticMemory` + `VectorStore`/`Embedder` | 内存 / pgvector + OpenAI | 语义检索 / RAG |

后续小节分别介绍这三层的后端选项与配置。

## 2. 短期记忆后端: Session / Working Memory

### 2.1 Session 服务

`pkg/session` 提供 `Session` 抽象和多种实现:

| 实现 | 文件 | 特点 |
|------|------|------|
| 内存实现 | `session.NewInMemoryService()` | 纯内存, 适合开发/测试 |
| MySQL 实现 | `pkg/session/mysql` | 会话 & 事件持久化到 MySQL |
| PostgreSQL 实现 | `pkg/session/postgres` | 会话 & 事件持久化到 PostgreSQL |

> 建议: 开发环境使用 `InMemoryService`, 生产环境使用 MySQL/Postgres。

### 2.2 Working Memory 后端

Working Memory 使用 `WorkingMemoryManager` + `Backend` 组合:

```go
manager, err := memory.NewWorkingMemoryManager(&memory.WorkingMemoryConfig{
    Backend:  backend,           // 任意实现 BackendProtocol 的后端
    BasePath: "/working_memory/",
    Scope:    memory.ScopeThread,
})
```

常见后端:

| 后端 | 文件 | 说明 |
|------|------|------|
| `backends.StateBackend` | `pkg/backends/state.go` | 会话级内存存储, 适合临时状态 |
| `backends.StoreBackend` | `pkg/backends/store.go` | 基于 `store.Store` 的持久化后端 |
| `backends.FilesystemBackend` | `pkg/backends/filesystem.go` | 使用沙箱文件系统 |
| `backends.CompositeBackend` | `pkg/backends/composite.go` | 可按路径前缀路由到不同后端 |

### 2.3 配置示例（agentsdk.yaml）

建议在你的应用层定义一个 session / working_memory 段, 显式区分短期记忆后端。例如:

```yaml
session:
  backend: memory        # memory | mysql | postgres
  dsn: ""                # 对于 mysql/postgres 生效

working_memory:
  enabled: true
  scope: "thread"        # "thread" | "resource"
  ttl: 0                 # 0 表示不过期
```

> 当前版本中, Session/WorkingMemory 的具体初始化逻辑由应用负责, 上述配置是推荐结构, 可根据项目需要裁剪。

## 3. 长期记忆后端: 文本记忆（Text Memory）

长期文本记忆由 `memory.Manager` + `AgentMemoryMiddleware` 提供:

- 存储结构: Markdown 文件;
- 组织方式: `memory.Scope` 生成 namespace;
- 访问方式: `memory_write` / `memory_search` 工具 + Manager API。

常见后端:

| 后端 | 文件 | 说明 |
|------|------|------|
| `backends.LocalBackend` | `pkg/backends/local.go` | 基于本地文件系统 |
| `backends.CompositeBackend` | `pkg/backends/composite.go` | 路由不同前缀到不同真实后端 |

示例:

```yaml
memory:
  text:
    enabled: true
    path: "/memories/"
    base_namespace: ""   # 可用于多租户隔离
```

更多用法见: `docs/content/4.guides/memory-advanced.md`。

## 4. 语义记忆后端: VectorStore + Embedder

语义记忆由三部分组成:

1. `vector_stores` - 向量存储;
2. `embedders` - 向量生成;
3. `semantic_memory` - 组合和命名空间策略。

### 4.1 VectorStore 适配器

`pkg/vector/store.go` 定义了 `VectorStore` 接口:

```go
type VectorStore interface {
    Upsert(ctx context.Context, docs []Document) error
    Delete(ctx context.Context, ids []string) error
    Query(ctx context.Context, q Query) ([]Hit, error)
    Close() error
}
```

已内置的实现:

| kind | 实现文件 | 说明 |
|------|----------|------|
| `memory` | `pkg/vector/memory_store.go` | 纯内存向量存储, 适合本地示例与测试 |
| `pgvector` | `pkg/vector/pgvector/store.go` | 基于 PostgreSQL + pgvector 扩展 |

### 4.2 Embedder 适配器

`pkg/vector/embedder.go` 定义了 `Embedder` 接口:

```go
type Embedder interface {
    EmbedText(ctx context.Context, texts []string) ([][]float32, error)
}
```

已内置的实现:

| kind | 实现文件 | 说明 |
|------|----------|------|
| `mock` | `pkg/vector/mock_embedder.go` | 简单伪 embedding, 用于示例/测试 |
| `openai` | `pkg/vector/openai_embedder.go` | 调用 OpenAI 兼容的 Embeddings API |

### 4.3 配置示例

```yaml
vector_stores:
  - name: main
    kind: pgvector
    dsn: postgres://user:password@localhost:5432/agentsdk?sslmode=disable
    table: agent_vectors
    metric: cosine
    dimension: 1536

embedders:
  - name: default
    kind: openai
    model: text-embedding-3-small
    env_api_key: OPENAI_API_KEY

semantic_memory:
  enabled: true
  store: main
  embedder: default
  top_k: 8
  namespace_scope: resource
```

在示例环境中, 可以使用纯内存实现:

```yaml
vector_stores:
  - name: main
    kind: memory

embedders:
  - name: default
    kind: mock

semantic_memory:
  enabled: true
  store: main
  embedder: default
  top_k: 8
  namespace_scope: resource
```

更多用法与示例详见:

- `docs/content/4.examples/memory-semantic.md`
- `docs/content/4.examples/workflow-semantic.md`
- `examples/memory-semantic`
- `examples/memory-semantic-session`
