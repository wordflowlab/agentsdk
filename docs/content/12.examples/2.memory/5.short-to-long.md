---
title: 从短期记忆到长期记忆
description: 使用 Session + LongTermBridge + SemanticMemory 实现跨会话长期记忆
navigation: false
---

# 从短期记忆到长期记忆

本指南展示如何把 **短期记忆(Session)** 中的对话内容, 通过一个统一的桥接层保存到 **长期语义记忆(SemanticMemory)** 中, 实现「教学会话 → 长期记忆 → 新会话依然能回忆」的闭环。

对应代码示例: `examples/memory-semantic-session/main.go`

## 1. 场景: 教学会话 → 学生会话

典型流程:

1. 教学会话(teaching session):
   - 用户告诉 Agent 某些“需要被长期记住”的知识/秘密;
   - 这些对话事件首先只存在于 Session(短期)。
2. 保存到长期记忆:
   - 通过 `LongTermBridge.SaveSessionToSemanticMemory` 从 Session 读取事件;
   - 将内容拼接为一篇长文, 写入 `SemanticMemory` 对应的向量索引。
3. 新会话(student session):
   - 新的 Session 中, 即使上下文为空;
   - 仍然可以通过 `SemanticMemory.Search` 回忆之前存入的知识。

这种模式非常适合:

- 「教学 / 设置」类会话, 如“记住我喜欢的风格”“记住我的密钥”等;
- 不希望所有历史都留在短期上下文, 而是只抽取部分知识写入长期记忆。

## 2. 准备短期记忆: Session 服务

首先需要一个 `session.Service` 作为短期记忆存储:

```go
import "github.com/wordflowlab/agentsdk/pkg/session"

svc := session.NewInMemoryService()

appName := "ltm_demo"
userID := "alice"

teachingSessionID := "teaching-session"
studentSessionID := "student-session"
```

在示例中我们使用内存 Session, 生产环境可以换成 MySQL/PostgreSQL 实现。

创建教学会话并写入事件:

```go
teachingSess, err := svc.Create(ctx, &session.CreateRequest{
    AppName:  appName,
    UserID:   userID,
    AgentID:  "teacher-agent",
    Metadata: map[string]interface{}{"kind": "teaching"},
})

teachEvents := []*session.Event{
    {
        ID:        "evt-teach-1",
        Timestamp: time.Now(),
        Author:    "user",
        Content: types.Message{
            Role:    types.RoleUser,
            Content: "My secret is 0xabcd",
        },
    },
    {
        ID:        "evt-teach-2",
        Timestamp: time.Now().Add(1 * time.Second),
        Author:    "assistant",
        Content: types.Message{
            Role:    types.RoleAssistant,
            Content: "Got it, I will remember your secret.",
        },
    },
}

for _, ev := range teachEvents {
    _ = svc.AppendEvent(ctx, (*teachingSess).ID(), ev)
}
```

此时“0xabcd”这个信息只存在于教学 Session 的事件里, 还不属于长期记忆。

## 3. 准备长期语义记忆: SemanticMemory

接下来配置一个简单的语义记忆, 示例中使用内存向量存储 + MockEmbedder:

```go
import (
    "github.com/wordflowlab/agentsdk/pkg/memory"
    "github.com/wordflowlab/agentsdk/pkg/vector"
)

vecStore := vector.NewMemoryStore()
embedder := vector.NewMockEmbedder(16)

semMem := memory.NewSemanticMemory(memory.SemanticMemoryConfig{
    Store:          vecStore,
    Embedder:       embedder,
    NamespaceScope: "user", // 按 user 维度隔离长期记忆
    TopK:           3,
})
```

生产环境可以在 `agentsdk.yaml` 中配置 `pgvector + openai` 等适配器, 然后通过应用层初始化 `SemanticMemory`。

## 4. 使用 LongTermBridge: 从 Session 保存到 SemanticMemory

`pkg/memory/bridge.go` 提供了一个轻量工具 `LongTermBridge`, 用于把 Session 事件写入语义记忆:

```go
import "github.com/wordflowlab/agentsdk/pkg/memory"

bridge := &memory.LongTermBridge{
    Sessions:       svc,
    SemanticMemory: semMem,
}
```

核心方法:

```go
err := bridge.SaveSessionToSemanticMemory(
    ctx,
    appName,              // app 名称
    userID,               // 用户 ID
    (*teachingSess).ID(), // Session ID
    map[string]interface{}{"user_id": userID}, // 命名空间元数据
    &memory.LongTermBridgeConfig{
        MinTokens: 3,     // 可选: 过滤过短内容
    },
)
```

内部逻辑概览:

- 从 `session.Service` 中获取指定 Session;
- 遍历事件, 抽取所有有文本内容的 `user`/`assistant` 消息;
- 将它们拼成一个多行文本:
  ```text
  user: My secret is 0xabcd
  assistant: Got it, I will remember your secret.
  ```
- 构造 `docID = appName/userID/sessionID`;
- 携带元数据:
  - `user_id`(用于命名空间),
  - `app_name`,
  - `session_id`;
- 调用 `SemanticMemory.Index` 写入向量索引。

> 注意: 这里 bridge 不负责“过滤哪些是知识,哪些是闲聊”。这是一个简单的通道,具体策略可在上层增加:只对特定类型的 Session 调用、配合 evals 对事件打分后再写入等。

## 5. 在新会话中使用长期语义记忆

保存成功后, 在新 Session 中可以直接通过 `SemanticMemory.Search` 做语义检索:

```go
studentSess, err := svc.Create(ctx, &session.CreateRequest{
    AppName:  appName,
    UserID:   userID,
    AgentID:  "student-agent",
    Metadata: map[string]interface{}{"kind": "student"},
})

question := "What is my secret?"

hits, err := semMem.Search(ctx,
    question,
    map[string]interface{}{"user_id": userID}, // 与保存时的 namespace 一致
    3,
)

fmt.Println("Semantic search hits:")
for _, h := range hits {
    fmt.Printf("  ID=%s, score=%.4f\n", h.ID, h.Score)
    if txt, ok := h.Metadata["text"].(string); ok {
        fmt.Printf("    text: %s\n", txt)
    }
}
fmt.Printf("New session: %s\n", (*studentSess).ID())
```

在真实应用中,你可以:

- 在 Agent 的工具或中间件里注入一个 `semantic_search` 工具, 由 LLM 自己调用来查询长期记忆;
- 或在工作流中显式调用 `semMem.Search`, 将检索到的上下文拼入 prompt, 类似 `workflow-semantic` 示例。

## 6. 与文件长期记忆的协同

本指南聚焦于「Session → SemanticMemory」这条路径, 你也可以将其与文件式长期记忆组合使用:

- 文件长期记忆:
  - 使用 `AgentMemoryMiddleware` + `memory.Scope` + `memory_write` 将结构化笔记写入 Markdown 文件;
  - 便于人工审阅和版本管理。
- 语义长期记忆:
  - 使用 `LongTermBridge` 将 Session 对话中抽取出的知识写入向量索引;
  - 适合在大规模知识中做语义相似度检索。

推荐实践:

- 对「固定结构的知识」(设计决策、项目规范等): 先写到文件长期记忆中;
- 对「更口语化、分散在对话中的知识」: 使用 `LongTermBridge` 自动抽取 Session 内容, 写入语义记忆。

## 7. 总结

通过 `Session + LongTermBridge + SemanticMemory` 的组合, 你可以实现:

- 清晰的记忆分层:
  - 短期: Session/Working Memory, 只为当前会话服务;
  - 长期: 文件 + 语义记忆, 跨会话持久。
- 统一的“上岸”路径:
  - 不同会话中的知识性信息, 都可以通过同一个 helper 写入长期语义记忆;
  - 上层可以自由选择: 哪些 Session 需要“晋升”为长期记忆。

接下来你可以:

- 在自己的业务中为特定类型的 Session（例如「设置」「教学」「配置」）增加保存长期记忆的流程;
- 将 `SemanticMemory.Search` 封装为工具或工作流节点, 让 Agent/工作流自动利用这些长期记忆。
