---
title: 多用户/多场景记忆封装
description: 使用 memory.Scope 封装用户/项目/资源级记忆工具
navigation: false
---

# 多用户/多场景记忆封装示例

本示例展示如何:

- 使用 `AgentMemoryMiddleware` 提供的底层 `memory_write` 工具。
- 使用 `memory.Scope` 为「用户 / 项目 / 资源 / 共享」生成 namespace。
- 在应用层封装更高层语义的工具, 例如:
  - `user_preference_write`
  - `project_fact_write`
  - `resource_note_write`

示例代码路径: `examples/memory-advanced/main.go`

> 这个示例不需要真实模型, 也不依赖完整 Agent。它专注于如何在应用侧组织和写入多用户 + 多场景的长期记忆。

如果你希望进一步将这些长期记忆暴露给语义检索（RAG）, 可以结合:

- 文件式长期记忆: 本文示例中的 `memory.Scope + memory_write`；
- 语义记忆: `SemanticMemory` 与 `LongTermBridge`（见 `examples/memory-semantic-session`）,
  将特定 Session 中的知识性内容保存到向量索引中, 实现「短期 → 长期(语义)」的统一路径。

## 1. 底层 Backend 与 AgentMemory 中间件

```go
ctx := context.Background()

// 1. 构建 Backend: 默认使用 StateBackend + 本地 ./memories-advanced 目录
stateBackend := backends.NewStateBackend()
localMemBackend := backends.NewLocalBackend("./memories-advanced")

memoryBackend := backends.NewCompositeBackend(
    stateBackend,
    []backends.RouteConfig{
        {
            Prefix:  "/memories/",
            Backend: localMemBackend,
        },
    },
)

// 2. 创建 AgentMemoryMiddleware, 以便获取底层 memory_write 工具
memoryMW, err := middleware.NewAgentMemoryMiddleware(&middleware.AgentMemoryMiddlewareConfig{
    Backend:    memoryBackend,
    MemoryPath: "/memories/",
})
if err != nil {
    log.Fatalf("create AgentMemoryMiddleware failed: %v", err)
}

// 3. 通过中间件栈收集工具
stack := middleware.NewStack([]middleware.Middleware{memoryMW})
allTools := stack.Tools()

var memoryWriteTool tools.Tool
for _, t := range allTools {
    if t.Name() == "memory_write" {
        memoryWriteTool = t
        break
    }
}
if memoryWriteTool == nil {
    log.Fatalf("memory_write 工具未找到, 请检查 AgentMemoryMiddleware 实现")
}
```

## 2. 封装工具 1: 用户偏好写入

```go
// userPreferenceTool 封装: 写用户偏好 -> users/<user-id>/profile/prefs.md
type userPreferenceTool struct {
    userID      string
    memoryWrite tools.Tool
}

func (t *userPreferenceTool) Name() string { return "user_preference_write" }

func (t *userPreferenceTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "preference": {
                "type":        "string",
                "description": "Plain-language description of the user preference.",
            },
        },
        "required": []string{"preference"},
    }
}

func (t *userPreferenceTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    rawPref, _ := input["preference"].(string)
    if rawPref == "" {
        return nil, fmt.Errorf("preference is required")
    }

    scope := memory.Scope{
        UserID: t.userID,
        Shared: false, // 用户级
    }
    ns := scope.Namespace()      // "" => 由 BaseNamespace(users/<user-id>) 控制
    file := "profile/prefs.md"   // 相对于 namespace 的文件名

    payload := map[string]interface{}{
        "file":      file,
        "namespace": ns,
        "mode":      "append",
        "title":     "User preference",
        "content":   rawPref,
    }

    return t.memoryWrite.Execute(ctx, payload, tc)
}
```

## 3. 封装工具 2: 项目事实/约定

```go
// projectFactTool 将记忆写入 projects/<project-id>/facts.md.
// Shared 控制它是用户级还是全局共享:
// - Shared=false: /memories/users/<user-id>/projects/<project-id>/facts.md
// - Shared=true : /memories/projects/<project-id>/facts.md
type projectFactTool struct {
    userID      string
    projectID   string
    shared      bool
    memoryWrite tools.Tool
}

func (t *projectFactTool) Name() string { return "project_fact_write" }

func (t *projectFactTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "fact": {
                "type":        "string",
                "description": "Project-level fact or convention to remember.",
            },
        },
        "required": []string{"fact"},
    }
}

func (t *projectFactTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    fact, _ := input["fact"].(string)
    if fact == "" {
        return nil, fmt.Errorf("fact is required")
    }

    scope := memory.Scope{
        UserID:    t.userID,
        ProjectID: t.projectID,
        Shared:    t.shared,
    }
    ns := scope.Namespace()

    payload := map[string]interface{}{
        "file":      "facts.md",
        "namespace": ns,
        "mode":      "append",
        "title":     "Project fact",
        "content":   fact,
    }

    return t.memoryWrite.Execute(ctx, payload, tc)
}
```

## 4. 封装工具 3: 资源级笔记 (文章/小说/歌曲/PPT 等)

```go
// resourceNoteTool 将笔记写入 (项目可选) + 资源路径下:
//   [projects/<project-id>/]resources/<type>/<id>/notes.md
// Shared=false => 用户级
// Shared=true  => 全局共享
type resourceNoteTool struct {
    userID       string
    projectID    string
    resourceType string // "article" | "novel" | "song" | "ppt" | ...
    resourceID   string
    shared       bool
    memoryWrite  tools.Tool
}

func (t *resourceNoteTool) Name() string { return "resource_note_write" }

func (t *resourceNoteTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    note, _ := input["note"].(string)
    if note == "" {
        return nil, fmt.Errorf("note is required")
    }

    scope := memory.Scope{
        UserID:       t.userID,
        ProjectID:    t.projectID,
        ResourceType: t.resourceType,
        ResourceID:   t.resourceID,
        Shared:       t.shared,
    }
    ns := scope.Namespace()

    payload := map[string]interface{}{
        "file":      "notes.md",
        "namespace": ns,
        "mode":      "append",
        "title":     "Resource note",
        "content":   note,
    }

    return t.memoryWrite.Execute(ctx, payload, tc)
}
```

## 5. 示例 main: 依次调用三个封装工具

完整代码见 `examples/memory-advanced/main.go`, 关键部分如下:

```go
// 构造封装工具 (以 user=alice, project=demo, article=abc 为例)
userID := "alice"
projectID := "demo"

userPrefTool := &userPreferenceTool{
    userID:      userID,
    memoryWrite: memoryWriteTool,
}

projectFact := &projectFactTool{
    userID:      userID,
    projectID:   projectID,
    shared:      false, // 用户级项目记忆
    memoryWrite: memoryWriteTool,
}

resourceNote := &resourceNoteTool{
    userID:       userID,
    projectID:    projectID,
    resourceType: "article",
    resourceID:   "abc123",
    shared:       true, // 所有人共享的文章笔记
    memoryWrite:  memoryWriteTool,
}

toolCtx := &tools.ToolContext{
    Services: map[string]interface{}{
        "memory_write": memoryWriteTool,
    },
}

// 1) 写用户偏好
userPrefTool.Execute(ctx, map[string]interface{}{
    "preference": "Alice 喜欢 grep 风格的搜索和简洁的代码 diff。",
}, toolCtx)

// 2) 写项目事实
projectFact.Execute(ctx, map[string]interface{}{
    "fact": "demo 项目在生产环境只允许使用只读数据库连接。",
}, toolCtx)

// 3) 写资源笔记
resourceNote.Execute(ctx, map[string]interface{}{
    "note": "文章 abc123 主要介绍了如何用文件+grep 替代向量RAG。",
}, toolCtx)
```

运行:

```bash
cd examples
go run memory-advanced/main.go
```

完成后, 查看 `./memories-advanced` 目录, 你会看到:

- 用户级 profile/prefs.md (用户偏好)
- 用户级 projects/demo/facts.md (项目事实)
- 全局级 resources/article/abc123/notes.md (资源笔记, 所有人共享)

这就是“一套 namespace 规则 + Scope + 封装工具”组合出来的多用户/多场景记忆管理。
